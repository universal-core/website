"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[20569],{58860:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>d});var a=n(37953);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),y=s,d=m["".concat(l,".").concat(y)]||m[y]||g[y]||r;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=y;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:s,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},64118:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>m});n(37953);var a=n(58860);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}const o={title:"Essentials of TypeScript Classes",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",slug:"typescript-classes",authors:"abdullah_numan",tags:["typescript"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-11-07-ts-classes/social.png",hide_table_of_contents:!1},l=void 0,p={permalink:"/blog/typescript-classes",source:"@site/blog/2023-11-07-ts-classes.md",title:"Essentials of TypeScript Classes",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",date:"2023-11-07T00:00:00.000Z",formattedDate:"November 7, 2023",tags:[{label:"typescript",permalink:"/blog/tags/typescript"}],readingTime:20.06,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"Essentials of TypeScript Classes",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",slug:"typescript-classes",authors:"abdullah_numan",tags:["typescript"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-11-07-ts-classes/social.png",hide_table_of_contents:!1},prevItem:{title:"A Detailed Guide on kubectl describe",permalink:"/blog/kubectl-describe-pod"},nextItem:{title:"kubectl port-forward - Kubernetes Port Forwarding Explained",permalink:"/blog/kubectl-port-forward"},relatedPosts:[{title:"Dictionaries in TypeScript -  How to Ensure Type Safety",description:"This post is provides a guide on how to ensure type safety to dictionaries with TypeScript.",permalink:"/blog/typescript-dictionary",formattedDate:"November 11, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:24.605,date:"2024-11-11T00:00:00.000Z"},{title:"A Guide for Next.js with TypeScript",description:"We will explain the entire process of how to use Next.js in TypeScript",permalink:"/blog/next-js-with-typescript",formattedDate:"June 10, 2024",authors:[{name:"Michael Hungbo",title:"Software Developer",url:"https://github.com/Mich45",imageURL:"https://github.com/Mich45.png",key:"michael"}],readingTime:11.765,date:"2024-06-10T00:00:00.000Z"},{title:"A Detailed Guide on TypeScript Pick Type",description:"We'll deep dive into the TypeScript Pick utility type with examples and use cases.",permalink:"/blog/typescript-pick-utility-type",formattedDate:"September 30, 2022",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:6.475,date:"2022-09-30T00:00:00.000Z"}],authorPosts:[{title:"Ref Forwarding with React forwardRef",description:"We discuss in detail how ref forwarding with React forwardRef works.",permalink:"/blog/react-forwardref",formattedDate:"June 12, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:19.785,date:"2024-06-12T00:00:00.000Z"},{title:"Error Handling With try, catch and finally Blocks in JavaScript",description:"We'll see how to handle errors in JavaScript using the try/catch/finally blocks.",permalink:"/blog/javascript-try-catch-finally",formattedDate:"October 30, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:15.29,date:"2024-10-30T00:00:00.000Z"},{title:"Dictionaries in TypeScript -  How to Ensure Type Safety",description:"This post is provides a guide on how to ensure type safety to dictionaries with TypeScript.",permalink:"/blog/typescript-dictionary",formattedDate:"November 11, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:24.605,date:"2024-11-11T00:00:00.000Z"}]},c={authorsImageUrls:[void 0]},m=[{value:"Introduction",id:"introduction",level:2},{value:"Overview",id:"overview",level:2},{value:"Typing Class Members in TypeScript",id:"typing-class-members-in-typescript",level:2},{value:"Typing Fields in TypeScript",id:"typing-fields-in-typescript",level:3},{value:"TypeScript Classes - Constructor Functions",id:"typescript-classes---constructor-functions",level:3},{value:"TypeScript Classes - Typing Methods",id:"typescript-classes---typing-methods",level:3},{value:"TypeScript Classes - Typing Accessors",id:"typescript-classes---typing-accessors",level:3},{value:"<code>this</code> Object in TypeScript Classes",id:"this-object-in-typescript-classes",level:2},{value:"TypeScript Classes - Arrow Functions for Permanently Attaching <code>this</code> Object",id:"typescript-classes---arrow-functions-for-permanently-attaching-this-object",level:3},{value:"TypeScript Classes - Context Binding with <code>this</code> Parameter",id:"typescript-classes---context-binding-with-this-parameter",level:3},{value:"TypeScript Generic Classes",id:"typescript-generic-classes",level:2},{value:"TypeScript Classes - Multiple Interfaces with <code>implements</code>",id:"typescript-classes---multiple-interfaces-with-implements",level:2},{value:"TypeScript Classes - Relationship Between Class Types",id:"typescript-classes---relationship-between-class-types",level:2},{value:"TypeScript Classes - Classes with Identical Shapes are Type Compliant",id:"typescript-classes---classes-with-identical-shapes-are-type-compliant",level:3},{value:"TypeScript Classes - Subtyped Classes are Type Compliant",id:"typescript-classes---subtyped-classes-are-type-compliant",level:3},{value:"Summary",id:"summary",level:2}],g={toc:m},y="wrapper";function d(e){var{components:t}=e,n=i(e,["components"]);return(0,a.yg)(y,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){s(e,t,n[t])}))}return e}({},g,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h2",{id:"introduction"},"Introduction"),(0,a.yg)("p",null,"TypeScript supports all the features of JavaScript Class syntax introduced in ES2015. Basically, type annotations are applied to all members, namely: fields, constructors, methods and accessors -- and where applicable, parameters as well. TypeScript also bakes in a special syntax to class constructors called ",(0,a.yg)("strong",{parentName:"p"},"parameter properties")," which allows us to declare a class ",(0,a.yg)("strong",{parentName:"p"},"field")," from the constructor function's parameters."),(0,a.yg)("p",null,"A TypeScript class definition creates a type from itself and it is used to validate conformity of an instance. TypeScript allows generic classes with type parameters passed to the outer class definition. Usually, generic class type parameters are accepted as constructor parameters, but they can also be passed to fields, methods and accessors as well. A single TS class can implement multiple other ",(0,a.yg)("strong",{parentName:"p"},"interfaces"),", something that is done with the ",(0,a.yg)("inlineCode",{parentName:"p"},"implements")," keyword."),(0,a.yg)("p",null,"Besides type annotations, TypeScript adds member visibility across the prototype chain with three access modifiers: ",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," -- a feature distinct from how ES2022 implements member privacy with ",(0,a.yg)("inlineCode",{parentName:"p"},"#"),"."),(0,a.yg)("p",null,"JavaScript ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," keyword leads to some unpredictability in different ",(0,a.yg)("strong",{parentName:"p"},"call site")," contexts. TypeScript is geared to mitigate during development some of the call site uncertainties by allocating a possible ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter to a method's first argument."),(0,a.yg)("p",null,"Steps we'll cover in this post:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typing-class-members-in-typescript"},"Typing Class Members in TypeScript"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typing-fields-in-typescript"},"Typing Fields in TypeScript")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---constructor-functions"},"TypeScript Classes - Constructor Functions")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---typing-methods"},"TypeScript Classes - Typing Methods")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---typing-accessors"},"TypeScript Classes - Typing Accessors")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#this-object-in-typescript-classes"},(0,a.yg)("inlineCode",{parentName:"a"},"this")," Object in TypeScript Classes"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---arrow-functions-for-permanently-attaching-this-object"},"TypeScript Classes - Arrow Functions for Permanently Attaching ",(0,a.yg)("inlineCode",{parentName:"a"},"this")," Object")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---context-binding-with-this-parameter"},"TypeScript Classes - Context Binding with ",(0,a.yg)("inlineCode",{parentName:"a"},"this")," Parameter")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-generic-classes"},"TypeScript Generic Classes")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---multiple-interfaces-with-implements"},"TypeScript Classes - Multiple Interfaces with ",(0,a.yg)("inlineCode",{parentName:"a"},"implements"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---relationship-between-class-types"},"TypeScript Classes - Relationship Between Class Types"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---classes-with-identical-shapes-are-type-compliant"},"TypeScript Classes - Classes with Identical Shapes are Type Compliant")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---subtyped-classes-are-type-compliant"},"TypeScript Classes - Subtyped Classes are Type Compliant"))))),(0,a.yg)("h2",{id:"overview"},"Overview"),(0,a.yg)("p",null,"In this post, we focus on the essentials of class based programming in TypeScript using a simple ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class. We begin with how type annotations are applied to different class members and their parameters."),(0,a.yg)("p",null,"We first consider typing class fields and delve into details of their initialization options, particularly investigating ",(0,a.yg)("em",{parentName:"p"},"definite initialization")," with the bang ",(0,a.yg)("inlineCode",{parentName:"p"},"!")," operator and strict initialization with the ",(0,a.yg)("inlineCode",{parentName:"p"},"--strictPropertyInitialization")," flag."),(0,a.yg)("p",null,"We then familiarize with how member visibility is implemented in TypeScript. Member visibility in TypeScript classes is largely related to effective usage of prototypal heritage in JavaScript. However, in this post, we don't cover inheritance in TypeScript classes: for brevity, we only consider privacy of fields for a simple uninherited class and its instances. We also touch base on static fields which acts the same as that in JavaScript."),(0,a.yg)("p",null,"We elaborate on what ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields are and how they are limited to be initialized at the top or re/assigned from a constructor function. We extensively cover typing a constructor function with examples from our uninherited ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class and relate that constructor parameters are typed similar to any TS function. We end up learning how parameter properties work inside a constructor. Moving forward, we also work our way through easy-to-pick examples of typing methods and accessors, along with their parameters."),(0,a.yg)("p",null,"In the later half of this post, we zoom in on the way TypeScript mitigates errors related to the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object. We expound on how arrow functions and the special TS ",(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("inlineCode",{parentName:"strong"},"this")," parameter")," in non-arrow functions can be used for correctly setting a class method's ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object and also learn about some of their caveats."),(0,a.yg)("p",null,"We also explore generic classes with passed in type parameters and see examples of how TypeScript facilitates class conformity to multiple interfaces with the ",(0,a.yg)("inlineCode",{parentName:"p"},"implements")," keyword."),(0,a.yg)("p",null,"Towards the end, we briefly discuss the structural type system that TypeScript bases itself on. We observe with an example how instances of different but identically typed and subtype classes conform to a given class (or rather the type from it) and how a supertype cannot not conform to a subtype because of missing properties."),(0,a.yg)("p",null,"Before we begin with type annotation examples, in the next section, let's first go through how to set up the environment for using TypeScript."),(0,a.yg)("h2",{id:"typing-class-members-in-typescript"},"Typing Class Members in TypeScript"),(0,a.yg)("p",null,"A TypeScript class commonly has type annotations for its members and where applicable, their parameters. In the following sections, one by one, we cover the details of typing TypeScript class fields, constructor functions, methods, accessors and their parameters."),(0,a.yg)("p",null,"Let's start with typing fields."),(0,a.yg)("h3",{id:"typing-fields-in-typescript"},"Typing Fields in TypeScript"),(0,a.yg)("p",null,"Below is an unsophisticated example with a few fields for a ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n')),(0,a.yg)("p",null,"As you can notice, typing a class field in TypeScript is done like typing a variable. For example, as the usual story goes, the type of ",(0,a.yg)("inlineCode",{parentName:"p"},"username")," is being inferred from its initializer type. With the rest of the properties, we are being explicit about the types for ",(0,a.yg)("inlineCode",{parentName:"p"},"firstName"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"lastName")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"age!"),"."),(0,a.yg)("br",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Field Initialization")),(0,a.yg)("p",null,"TypeScript class syntax adds some particular options to field initializations. A field may be initialized at declaration, or remain uninitialized, or uninitialized but aimed to be initialized ",(0,a.yg)("strong",{parentName:"p"},"definitely")," at some point during runtime."),(0,a.yg)("p",null,"For example, in the ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class, ",(0,a.yg)("inlineCode",{parentName:"p"},"username")," field is assigned a random string and the name fields are uninitialized. Notice the ",(0,a.yg)("inlineCode",{parentName:"p"},"age!")," field with a bang!"),(0,a.yg)("br",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Definite Field Assignments")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"age")," above is uninitialized but it is accompanied by a bang (",(0,a.yg)("inlineCode",{parentName:"p"},"!"),") operator which is called the ",(0,a.yg)("em",{parentName:"p"},"definite assignment assertion operator"),". It is used to indicate that leaving the field uninitialized is good enough to avoid TypeScript ",(0,a.yg)("strong",{parentName:"p"},"strict property initialization")," (see next section) error but it is expected to be definitely assigned a value with the specified type at some point."),(0,a.yg)("p",null,"It is common to use definite assignments when fields are assigned to an instance by APIs from some external libraries:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'const joe = new User();\n\n// Set joe\'s age externally\njoe.age = getUserInfoFromStatsBureau("someId")?.data?.age;\n')),(0,a.yg)("br",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Strict Field Initialization")),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"--strictPropertyInitialization")," flag in TypeScript controls how strict field/property initialization should be. We can set the strictness of property initialization from the ",(0,a.yg)("inlineCode",{parentName:"p"},"tsconfig.json")," file using the following entry to ",(0,a.yg)("inlineCode",{parentName:"p"},"compilerOptions"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'// Inside tsconfig.json\n\n{\n  "compilerOptions": {\n    "strictPropertyInitialization": true\n  }\n}\n')),(0,a.yg)("p",null,"In TypeScript Playground, you can activate strict property initialization first by visiting the ",(0,a.yg)("inlineCode",{parentName:"p"},"TS Config")," dropdown and then selecting ",(0,a.yg)("inlineCode",{parentName:"p"},"strictPropertyInitialization")," from the ",(0,a.yg)("inlineCode",{parentName:"p"},"Type Checking")," section."),(0,a.yg)("p",null,"Setting ",(0,a.yg)("inlineCode",{parentName:"p"},'"strictPropertyInitialization": true')," necessitates all fields to either have an initializer, or they should be set in the constructor function, or they should be definitely assigned at a later point. Otherwise, TypeScript throws a ",(0,a.yg)("inlineCode",{parentName:"p"},"2564")," error:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"// With --strictPropertyInitialization\n\nclass User {\n  // Initialized, so no error\n  username = \"randomString\";\n\n  // Assigned in constructor, so no error\n  private firstName: string;\n\n  // Not assigned in constructor\n  private lastName: string; // Property 'lastName' has no initializer and is not definitely assigned in the constructor.(2564)\n\n  // Removing bang (!) also throws 2564 error\n  protected age: number; // Property 'age' has no initializer and is not definitely assigned in the constructor.(2564)\n\n  constructor(firstName: string) {\n    this.firstName = firstName;\n  }\n}\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Class Member / Field Visibility")),(0,a.yg)("p",null,"TypeScript offers ",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," visibility options for its members. These privacy options are different from how JavaScript implements member privacy in ES2022."),(0,a.yg)("p",null,"Visibility in TypeScript classes is a general feature applicable to ",(0,a.yg)("strong",{parentName:"p"},"all members"),". We are covering it for fields, but the same principles apply to methods as well."),(0,a.yg)("p",null,"Fields that are not designated any privacy are by default ",(0,a.yg)("inlineCode",{parentName:"p"},"public"),". We can access or set ",(0,a.yg)("inlineCode",{parentName:"p"},"public")," properties from an instance:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\nconst joe = new User();\njoe.username = "jos3ph";\njoe.firstName = "Joseph";\njoe.lastName = "Hiyden";\njoe.age = 63;\n\nconsole.log(joe.username); // "jos3ph"\nconsole.log(`${joe.firstName} ${joe.lastName}`); // "Joseph Hiyden"\nconsole.log(joe.age); // 63\n')),(0,a.yg)("p",null,"We have to explicitly state when a field or any member should be ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"protected"),". ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," visibility restricts member access and assignment to within the class. ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," limits the member to be accessed and set from its subclasses as well. This means that we can't access or set ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," fields from an instance. Attempting to do so, as shown in the series of log statements below, throws errors:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  username = \"randomString\";\n  private firstName: string;\n  private lastName: string;\n  protected age!: number;\n}\n\nconst joe = new User();\njoe.username = \"jos3ph\";\njoe.firstName = \"Joseph\"; // Property 'firstName' is private and only accessible within class 'User'.(2341)\njoe.lastName = \"Hidden\"; // Property 'firstName' is private and only accessible within class 'User'.(2341)\njoe.age = 63; // Property 'age' is protected and only accessible within class 'User' and its subclasses.(2445)\n\nconsole.log(joe.username);\nconsole.log(`${joe.firstName} ${joe.lastName}`); // 2341 Errors\nconsole.log(joe.age); // 2445 Error\n")),(0,a.yg)("br",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Static Members / Fields")),(0,a.yg)("p",null,"Just as in JavaScript, we set class members on TypeScript classes with the ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," keyword. Let's introduce a static field ",(0,a.yg)("inlineCode",{parentName:"p"},"userType")," to our ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  public static userType: string = "Guest";\n\n  username = "randomString";\n  protected age!: number;\n}\n\nconsole.log(User.userType); // "Guest"\n')),(0,a.yg)("p",null,"As it happens in JavaScript, static fields in TypeScript represent class properties. One thing to note is that while declaring static fields, we have to place privacy modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"public")," here, which we technically don't need, but just to make a point) ",(0,a.yg)("strong",{parentName:"p"},"before")," the ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," keyword. Otherwise, TypeScript feels ",(0,a.yg)("em",{parentName:"p"},"uncomfortable"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"'public' modifier must precede 'static' modifier.(1029)\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - ",(0,a.yg)("inlineCode",{parentName:"strong"},"readonly")," Fields")),(0,a.yg)("p",null,"TypeScript allows fields to be ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly"),". As it implies, ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields tempt not be assigned from an instance, even with a setter. They are legal to be initialized at the top declaration and also assigned inside the constructor:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  static userType: string = "Guest";\n\n  readonly _username: string = "randomString"; // No error at initialization\n  protected age!: number;\n\n  get username() {\n    return this._username;\n  }\n\n  set username(username: string) {\n    // Error while re/assignment from setter\n    this._username = username; // Cannot assign to \'_username\' because it is a read-only property.(2540)\n  }\n\n  constructor(username: string) {\n    this._username = username; // No error while assigned from constructor\n  }\n}\n\nconst dona = new User("trump");\n\n// Error while being assigned from instance property, but gets assigned at compilation\nconsole.log((dona._username = "trump_trippin")); // Cannot assign to \'_username\' because it is a read-only property.(2540)\n')),(0,a.yg)("h3",{id:"typescript-classes---constructor-functions"},"TypeScript Classes - Constructor Functions"),(0,a.yg)("p",null,"As you already have noticed above, just like in regular TS functions that take parameters, class constructor parameters also get annotated with their types. Below is a more common example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  private firstName: string;\n  private lastName: string;\n  protected age!: number;\n\n  constructor(firstName: string, lastName: string) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n')),(0,a.yg)("p",null,"It is important to note that a constructor function in a TypeScript class does ",(0,a.yg)("strong",{parentName:"p"},"not")," take types as parameters. In other words, there is nothing like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  // Constructor fn cannot accept type param\n  constructor<AbsurdTypeParam>() {}\n}\n")),(0,a.yg)("p",null,"Instead, the class declaration itself takes type parameters. Type parameters passed to a class are useful for defining ",(0,a.yg)("strong",{parentName:"p"},"generic class types"),", since a class ends up creating its own type. We'll explore generic classes in a ",(0,a.yg)("a",{parentName:"p",href:"#typescript-generic-classes"},"later section"),"."),(0,a.yg)("br",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TS Classes - Constructor Return Type")),(0,a.yg)("p",null,"It should be also noted that we do ",(0,a.yg)("strong",{parentName:"p"},"not")," need to type the return value of a TypeScript class constructor. Because, it ",(0,a.yg)("strong",{parentName:"p"},"always")," returns the instance's type, which is the type created from the class."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  private firstName: string;\n  private lastName: string;\n  protected age!: number;\n\n  // Constructor\'s return type is the type of the class\' instance\n  constructor(firstName: string, lastName: string) {\n    // constructor User(firstName: string, lastName: string): User\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n\n// joe is of type User\nconst joe = new User("Joe", "Hiyden"); // joe: User\n')),(0,a.yg)("br",null),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TypeScript Class Creates a Type")),(0,a.yg)("p",null,"It should be pretty obvious that a TypeScript class creates a type from itself:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'// joe is of type User\nconst joe = new User("Joe", "Hiyden"); // joe: User\n')),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Typescript Classes - Parameter Properties")),(0,a.yg)("p",null,"In TypeScript, we can turn a constructor parameter into a class property using ",(0,a.yg)("strong",{parentName:"p"},"parameter properties"),". The way to implement parameter properties is by designating field visibility modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"private"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected"),") and/or accessor modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"readonly"),") to respective constructor parameters, instead of declaring field definitions that we usually perform at the top:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected age!: number;\n\n  // Use field modifiers to declare parameter properties in constructor\n  constructor(private firstName: string, private lastName: string) {\n    // No assignments inside constructor body needed\n  }\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nconst joe = new User("Joe", "Hiyden");\njoe.firstName; // Property \'firstName\' is private and only accessible within class \'User\'.(2341)\nconsole.log(joe.fullName()); // "Joe Hiyden"\n')),(0,a.yg)("p",null,"Above, we have a reworked ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class where we no longer need to declare ",(0,a.yg)("inlineCode",{parentName:"p"},"firstName")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"lastName")," as fields at the top. Notice closely that we also don't need to carry out respective field assignments inside the constructor body. This way, TypeScript neatly keeps our code compact."),(0,a.yg)("h3",{id:"typescript-classes---typing-methods"},"TypeScript Classes - Typing Methods"),(0,a.yg)("p",null,"Applying type annotations to class methods is easy and follow the same principles as other functions. We already have the example of ",(0,a.yg)("inlineCode",{parentName:"p"},"fullName()")," method above that has an inferred return type of ",(0,a.yg)("inlineCode",{parentName:"p"},"string"),". In the below code, ",(0,a.yg)("inlineCode",{parentName:"p"},"greetUserWith()")," is another method that has an explicit return type of ",(0,a.yg)("inlineCode",{parentName:"p"},"string"),". It is annotated a ",(0,a.yg)("inlineCode",{parentName:"p"},"string")," parameter as well:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string): string {\n    return `${greeting}, ${this.fullName()}`;\n  }\n}\n\nconst joe = new User("Joe", "Hiyden");\nconsole.log(joe.fullName()); // "Joe Hiyden"\nconsole.log(joe.greetUserWith("Hello")); // "Hello, Joe Hiyden"\n')),(0,a.yg)("h3",{id:"typescript-classes---typing-accessors"},"TypeScript Classes - Typing Accessors"),(0,a.yg)("p",null,"In a similar vein, we can annotate types for accessor function parameters. Let's see how to do that for our ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," ",(0,a.yg)("inlineCode",{parentName:"p"},"_age")," field:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected _age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  get age(): number {\n    return this._age;\n  }\n\n  set age(age: number) {\n    this._age = age;\n  }\n}\n\nconst joe = new User("Joe", "Hiyden");\njoe.age = 20;\nconsole.log(joe.age); // 20\n')),(0,a.yg)("p",null,"It is worth noting that although we can annotate a type for the return value of ",(0,a.yg)("inlineCode",{parentName:"p"},"get")," accessors, TypeScript complains if we assign a type for the return value of setters. Annotating a return type for setters is not allowed, so the following is invalid:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"set age(age: number): number { // A 'set' accessor cannot have a return type annotation.(1095)\n    this._age = age;\n};\n")),(0,a.yg)("br",null),(0,a.yg)("p",null,"There are a couple of quirks related to accessors typing in TypeScript. Let's consider them now."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TS Classes - Setter Parameter Type Inferred from Existing Getter Param Type")),(0,a.yg)("p",null,"For example, the above ",(0,a.yg)("inlineCode",{parentName:"p"},"age()")," ",(0,a.yg)("strong",{parentName:"p"},"setter")," can have its parameter type omitted. That's because when a getter exists, the setter's type parameter is inferred from the ",(0,a.yg)("strong",{parentName:"p"},"return type")," of getter:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected _age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  // Existing getter with `number` return type\n  get age(): number {\n    return this._age;\n  }\n\n  // Type of setter parameter inferred from return type of existing getter\n  set age(age) {\n    // (parameter) age: number\n    this._age = age;\n  }\n}\n\nconst joe = new User("Joe", "Hidin");\njoe.age = 20;\nconsole.log(joe.age); // 20\n')),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"TS Classes - Field With Only Getter is Set to ",(0,a.yg)("inlineCode",{parentName:"strong"},"readonly"))),(0,a.yg)("p",null,"When we have only a ",(0,a.yg)("inlineCode",{parentName:"p"},"get"),"ter method, and no corresponding setter, the field is automatically set to ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected _age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  get age(): number {\n    return this._age;\n  }\n}\n\nconst joe = new User("Just", "Kiddin");\n\n// Assignment gives error with read-only message\njoe.age = 20; // Cannot assign to \'age\' because it is a read-only property.(2540)\n')),(0,a.yg)("h2",{id:"this-object-in-typescript-classes"},(0,a.yg)("inlineCode",{parentName:"h2"},"this")," Object in TypeScript Classes"),(0,a.yg)("p",null,"In JavaScript, the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object on which a method is called depends on the ",(0,a.yg)("strong",{parentName:"p"},"call site")," of the method. At runtime, the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object can be one of the root causes of unpredictable outcomes of a method call. In this section, we consider how TypeScript has a couple of options for controlling the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object predictably in order to produce more stable outcomes."),(0,a.yg)("h3",{id:"typescript-classes---arrow-functions-for-permanently-attaching-this-object"},"TypeScript Classes - Arrow Functions for Permanently Attaching ",(0,a.yg)("inlineCode",{parentName:"h3"},"this")," Object"),(0,a.yg)("p",null,"As with JavaScript, when we want to permanently attach a class instance to a method, we can use the arrow syntax to define our method. For example, a redefined ",(0,a.yg)("inlineCode",{parentName:"p"},"fullName()")," method with arrow syntax:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  // highlight-next-line\n  fullName = () => `${this.firstName} ${this.lastName}`;\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n}\n\nconst joe = new User("Joe\'s", "Kiddin");\nconsole.log(joe.fullName()); // "Joe\'s Kiddin"\n\n// Doesn\'t lose `this` context, because it is permanently bound to instance\nconst jfn = joe.fullName;\nconsole.log(jfn()); // "Joe\'s Kiddin"\n')),(0,a.yg)("p",null,"As it happens in JavaScript, the arrow syntax permanently binds the ",(0,a.yg)("inlineCode",{parentName:"p"},"fullName")," method to the instance of class ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"joe")," here. So, regardless of whether we invoke it directly on ",(0,a.yg)("inlineCode",{parentName:"p"},"joe")," or extract it and call it later on, the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object remains ",(0,a.yg)("inlineCode",{parentName:"p"},"joe"),"."),(0,a.yg)("p",null,"One of the caveats of using context binding with arrow syntax is that in a derived class of ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", we can't access ",(0,a.yg)("inlineCode",{parentName:"p"},"super.fullName()")," as arrow functions don't have a ",(0,a.yg)("inlineCode",{parentName:"p"},"prototype")," property."),(0,a.yg)("h3",{id:"typescript-classes---context-binding-with-this-parameter"},"TypeScript Classes - Context Binding with ",(0,a.yg)("inlineCode",{parentName:"h3"},"this")," Parameter"),(0,a.yg)("p",null,"Another way TypeScript helps handle method context binding is that it spares the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object for the first parameter to every method or accessor. When we want to bind an instance of the class to the method, we can specify the instance as the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter and type it as the class itself. Like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  username = \"randomString\";\n  protected age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  // highlight-next-line\n  fullName(this: User) {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n}\n\nconst joe = new User(\"Joe's\", \"Hidin\");\nconsole.log(joe.fullName()); // \"Joe's Hidin\"\n\n// Error when taken out of context\nconst jfn = joe.fullName;\nconsole.log(jfn()); // The 'this' context of type 'void' is not assignable to method's 'this' of type 'User'.(2684)\n")),(0,a.yg)("p",null,"Context binding with the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter is specifically useful when we are sure to use the method on an instance of the ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class, and without taking it out of context. An added advantage is that we can also call it from a derived class using ",(0,a.yg)("inlineCode",{parentName:"p"},"super"),"."),(0,a.yg)("p",null,"The drawback, as we can see above, is that the method loses the instance as its ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," when it is extracted out of context."),(0,a.yg)("h2",{id:"typescript-generic-classes"},"TypeScript Generic Classes"),(0,a.yg)("p",null,"As it does with other generic types, TypeScript allows us to declare generic classes by passing in type parameters at class declaration. The passed in type can then be used to annotate types for any member inside the class."),(0,a.yg)("p",null,"Here's a simple example of generic class with modifications to an earlier example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User<T> {\n  readonly userType: T;\n\n  username = "randomString";\n  protected age!: number;\n\n  constructor(userType: T) {\n    this.userType = userType;\n  }\n}\n\ntype UserTypes = "Guest" | "Authenticated" | "Admin";\n\nconst joe = new User<string>("Guest");\nconst dae = new User<UserTypes>("Authenticated");\nconst dan = new User<UserTypes>("Unknown"); // Argument of type \'"Unknown"\' is not assignable to parameter of type \'UserTypes\'.(2345)\n\nconsole.log(joe.userType); // "Guest"\nconsole.log(dae.userType); // "Authenticated"\n')),(0,a.yg)("p",null,"It is, however, not legal to pass class type parameters to ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," members:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User<T> {\n  static readonly userType: T; // Static members cannot reference class type parameters.(2302)\n\n  username = "randomString";\n  protected age!: number;\n}\n')),(0,a.yg)("h2",{id:"typescript-classes---multiple-interfaces-with-implements"},"TypeScript Classes - Multiple Interfaces with ",(0,a.yg)("inlineCode",{parentName:"h2"},"implements")),(0,a.yg)("p",null,"It is possible for a TypeScript class to implement more than one interface. We use the ",(0,a.yg)("inlineCode",{parentName:"p"},"implements")," clause for this. Any interface that the class satisfies can be passed to ",(0,a.yg)("inlineCode",{parentName:"p"},"implements"),". For example, the following interfaces are all satisfied by the ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'interface Identifiable {\n  fullName(): string;\n}\n\ninterface Greetable {\n  greetUserWith(greeting: string): string;\n}\n\ninterface Updatable {\n  updateUsername(username: string): void;\n}\n\nclass User<T> implements Identifiable, Greetable, Updatable {\n  readonly userType: T;\n\n  username = "randomString";\n  protected age!: number;\n\n  constructor(\n    userType: T,\n    private firstName: string,\n    private lastName: string,\n  ) {\n    this.userType = userType;\n  }\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n\n  updateUsername(username: string) {\n    this.username = username;\n  }\n}\n\nconst joe = new User<string>("Guest", "Joe", "Hidden");\nconsole.log(joe.fullName()); // "Joe Hidden"\nconsole.log(joe.greetUserWith("Hello")); // "Hello, Joe Hidden"\n')),(0,a.yg)("p",null,"TypeScript throws a ",(0,a.yg)("inlineCode",{parentName:"p"},"2420")," error when a given interface property is not satisfied by the class. For example, for a ",(0,a.yg)("inlineCode",{parentName:"p"},"Registerable")," interface, the ",(0,a.yg)("inlineCode",{parentName:"p"},"register")," method is not implemented by ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", so it does not satisfy the ",(0,a.yg)("inlineCode",{parentName:"p"},"Registerable")," interface:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'interface Identifiable {\n  fullName(): string;\n}\n\ninterface Greetable {\n  greetUserWith(greeting: string): string;\n}\n\ninterface Updatable {\n  updateUsername(username: string): void;\n}\n\ninterface Registerable {\n  register(userId: string): void;\n}\n\n// Complains with 2420 error because `register()` method is missing in User\nclass User<T> implements Identifiable, Greetable, Updatable, Registerable {\n  //\n  readonly userType: T;\n\n  username = "randomString";\n  protected age!: number;\n\n  constructor(\n    userType: T,\n    private firstName: string,\n    private lastName: string,\n  ) {\n    this.userType = userType;\n  }\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n\n  updateUsername(username: string) {\n    this.username = username;\n  }\n}\n')),(0,a.yg)("h2",{id:"typescript-classes---relationship-between-class-types"},"TypeScript Classes - Relationship Between Class Types"),(0,a.yg)("p",null,"TypeScript has a structural type system. And in structural type systems, the shape of the class and their instances are enough to compare them."),(0,a.yg)("h3",{id:"typescript-classes---classes-with-identical-shapes-are-type-compliant"},"TypeScript Classes - Classes with Identical Shapes are Type Compliant"),(0,a.yg)("p",null,"If the shapes of two classes are identical, their types are compliant:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'// With --strictPropertyInitialization set to false\n\nclass User {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\nclass Admin {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\n// No complains when we type instance of Admin with User and vice versa, because User and Admin are structurally identical\nconst joe: User = new Admin(); // joe: User\nconst dona: Admin = new User(); // joe: Admin\n')),(0,a.yg)("p",null,"Here, we are able to type ",(0,a.yg)("inlineCode",{parentName:"p"},"joe"),": an instance of ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", and ",(0,a.yg)("inlineCode",{parentName:"p"},"dona"),": an instance of ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin")," because the shapes of the two classes are the same."),(0,a.yg)("h3",{id:"typescript-classes---subtyped-classes-are-type-compliant"},"TypeScript Classes - Subtyped Classes are Type Compliant"),(0,a.yg)("p",null,"Similarly, subtyped classes that have partial but the same members with a supertype is compliant to the supertype:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  username = \"randomString\";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\nclass Admin {\n  username = \"randomString\";\n  firstName: string;\n  lastName: string;\n  age!: number;\n  role: string = \"Admin\";\n}\n\n// No complains typing instance of Admin with User, because User is a subtype of Admin\nconst joe: User = new Admin(); // joe: User\n\n// This time around, we can't type instance of User with Admin, because missing property in supertype\nconst dae: Admin = new User(); // Property 'role' is missing in type 'User' but required in type 'Admin'.(2741)\n")),(0,a.yg)("p",null,"In this example, ",(0,a.yg)("inlineCode",{parentName:"p"},"joe"),", is still compliant to ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," because the ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin")," has all the members of ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," and an additional one. The opposite (",(0,a.yg)("inlineCode",{parentName:"p"},"dae: Admin"),") is not true though, because ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," has the missing member ",(0,a.yg)("inlineCode",{parentName:"p"},"role")," that is present in ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin"),"."),(0,a.yg)("h2",{id:"summary"},"Summary"),(0,a.yg)("p",null,"In this post, we have traversed a long way in our exploration of classes in TypeScript. We have covered the essentials of type annotation in TS classes. We began with how to type class fields, their initialization options and visibility modifiers. We touched on ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," fields, and with an example covered the concept of ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields that TypeScript implements. We have went through in depth how class constructor, method and accessor parameters, and their return values are annotated. We saw how ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," properties can be assigned from a constructor function, and how to implement parameter properties."),(0,a.yg)("p",null,"We also expounded on how arrow functions are used to bind a method permanently to an instance and discovered how the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter in TypeScript methods allows us to bind an instance more selectively to its methods."),(0,a.yg)("p",null,"Near the end, we learned about how a class should implement multiple interfaces with the ",(0,a.yg)("inlineCode",{parentName:"p"},"implement")," clause. We also explored how subtypes from classes are compliant to those from supertyped classes and and not the other way around because of TypeScript's structural typing system."))}d.isMDXComponent=!0}}]);